Index: LegacyEditor/LCE/Chunk.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"Chunk.hpp\"\r\n\r\n\r\nvoid Chunk::ensure_decompress(CONSOLE console) {\r\n    if (!isCompressed) {\r\n        // printf(\"cannot Chunk.ensure_decompress the chunk if its already decompressed\\n\");\r\n        return;\r\n    }\r\n\r\n    if (console == CONSOLE::NONE) {\r\n        // printf(\"passed CONSOLE::NONE to Chunk.ensure_decompress, results will not work\\n\");\r\n        return;\r\n    }\r\n\r\n    if (data == nullptr) {\r\n        // printf(\"chunk data is nullptr, cannot Chunk.ensure_decompress nothing\\n\");\r\n        return;\r\n    }\r\n\r\n    if (sectors == 0) {\r\n        // printf(\"cannot decompress data of chunk that has not been loaded\");\r\n        return;\r\n    }\r\n\r\n    isCompressed = false;\r\n\r\n    u32 dec_size_copy = dec_size;\r\n\r\n    Data decompData(dec_size);\r\n    // auto* decompressedData = new u8[dec_size];\r\n    switch (console) {\r\n        case CONSOLE::XBOX360:\r\n            dec_size_copy = XDecompress(decompData.start(), &decompData.size, data, size);\r\n            break;\r\n        case CONSOLE::PS3:\r\n            tinf_uncompress(decompData.start(), &decompData.size, data, size);\r\n            break;\r\n        case CONSOLE::WIIU:\r\n            tinf_zlib_uncompress(decompData.start(), &decompData.size, data, size);\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n\r\n    delete[] data;\r\n    data = nullptr;\r\n\r\n    if (rleFlag) {\r\n        Data rle(dec_size);\r\n        RLE_uncompress(decompData.start(), decompData.size, rle.start(), dec_size_copy);\r\n        data = rle.data;\r\n        rle.using_memory = false;\r\n        size = dec_size;\r\n        return;\r\n    }\r\n\r\n    data = decompData.data;\r\n    decompData.using_memory = false;\r\n    size = dec_size_copy;\r\n}\r\n\r\nvoid Chunk::ensure_compressed(CONSOLE console) {\r\n    if (isCompressed) {\r\n        // printf(\"cannot Chunk.ensure_compress if the chunk if its already compressed\\n\");\r\n        return;\r\n    }\r\n\r\n    if (console == CONSOLE::NONE) {\r\n        // printf(\"passed CONSOLE::NONE to Chunk.ensure_compress, results will not work\\n\");\r\n        return;\r\n    }\r\n\r\n    if (data == nullptr) {\r\n        // printf(\"chunk data is nullptr, cannot Chunk.ensure_compress nothing\\n\");\r\n        return;\r\n    }\r\n\r\n    if (sectors == 0) {\r\n        return;\r\n    }\r\n\r\n    dec_size = size;\r\n\r\n    if (rleFlag) {\r\n        u32 rle_size = size;\r\n        u8* rle_ptr = new u8[rle_size];\r\n        RLE_compress(rle_ptr, rle_size, data, size);\r\n        delete[] data;\r\n        data = rle_ptr;\r\n        size = rle_size;\r\n    }\r\n\r\n    // allocate memory and recompress\r\n    u8* comp_ptr = new u8[size];\r\n    uLongf comp_size = size;\r\n\r\n    switch (console) {\r\n        case CONSOLE::XBOX360:\r\n            // XCompress(comp_ptr, comp_size, data_ptr, data_size);\r\n            break;\r\n        case CONSOLE::PS3:\r\n            // tinf_compress(comp_ptr, comp_size, data_ptr, data_size);\r\n            break;\r\n        case CONSOLE::WIIU: {\r\n            ::compress(comp_ptr, &comp_size, data, size);\r\n            delete[] data;\r\n            data = comp_ptr;\r\n            size = comp_size;\r\n            break;\r\n        }\r\n        default:\r\n            break;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n
===================================================================
diff --git a/LegacyEditor/LCE/Chunk.cpp b/LegacyEditor/LCE/Chunk.cpp
--- a/LegacyEditor/LCE/Chunk.cpp	
+++ b/LegacyEditor/LCE/Chunk.cpp	
@@ -6,57 +6,55 @@
         // printf("cannot Chunk.ensure_decompress the chunk if its already decompressed\n");
         return;
     }
-
     if (console == CONSOLE::NONE) {
         // printf("passed CONSOLE::NONE to Chunk.ensure_decompress, results will not work\n");
         return;
     }
-
     if (data == nullptr) {
         // printf("chunk data is nullptr, cannot Chunk.ensure_decompress nothing\n");
         return;
     }
-
     if (sectors == 0) {
         // printf("cannot decompress data of chunk that has not been loaded");
         return;
     }
-
+    /*
+    printf("DECOMPRESSING\n");
+    DataManager chunkIn(data, size);
+    chunkIn.writeToFile(dir_path + "chunk_0_in.bin");
+    printf("0. %d\n", size);
+    */
     isCompressed = false;
 
     u32 dec_size_copy = dec_size;
-
-    Data decompData(dec_size);
-    // auto* decompressedData = new u8[dec_size];
+    Data comp(dec_size);
     switch (console) {
         case CONSOLE::XBOX360:
-            dec_size_copy = XDecompress(decompData.start(), &decompData.size, data, size);
+            dec_size_copy = XDecompress(comp.start(), &comp.size, start(), getSize());
             break;
         case CONSOLE::PS3:
-            tinf_uncompress(decompData.start(), &decompData.size, data, size);
+            tinf_uncompress(comp.start(), &comp.size, start(), getSize());
             break;
         case CONSOLE::WIIU:
-            tinf_zlib_uncompress(decompData.start(), &decompData.size, data, size);
+            tinf_zlib_uncompress(comp.start(), &comp.size, start(), getSize());
             break;
         default:
             break;
     }
+    takeover(comp);
 
-    delete[] data;
-    data = nullptr;
+    // DataManager chunk_norle(comp.start(), comp.size);
+    // chunk_norle.writeToFile(dir_path + "chunk_1_in.bin");
+    // printf("1. %d\n", comp.size);
 
     if (rleFlag) {
         Data rle(dec_size);
-        RLE_uncompress(decompData.start(), decompData.size, rle.start(), dec_size_copy);
-        data = rle.data;
-        rle.using_memory = false;
+        RLE_decompress(start(), size, rle.start(), dec_size_copy);
+        takeover(rle);
         size = dec_size;
         return;
     }
 
-    data = decompData.data;
-    decompData.using_memory = false;
-    size = dec_size_copy;
 }
 
 void Chunk::ensure_compressed(CONSOLE console) {
@@ -64,35 +62,37 @@
         // printf("cannot Chunk.ensure_compress if the chunk if its already compressed\n");
         return;
     }
-
     if (console == CONSOLE::NONE) {
         // printf("passed CONSOLE::NONE to Chunk.ensure_compress, results will not work\n");
         return;
     }
-
     if (data == nullptr) {
         // printf("chunk data is nullptr, cannot Chunk.ensure_compress nothing\n");
         return;
     }
-
     if (sectors == 0) {
         return;
     }
 
+    // DataManager chunk_decomp(data, size);
+    // chunk_decomp.writeToFile(dir_path + "chunk_2_DECOMP.bin");
+    // printf("2. DECOMPRESSED: %d\n", size);
+
     dec_size = size;
 
     if (rleFlag) {
-        u32 rle_size = size;
-        u8* rle_ptr = new u8[rle_size];
-        RLE_compress(rle_ptr, rle_size, data, size);
-        delete[] data;
-        data = rle_ptr;
-        size = rle_size;
+        Data rle(size);
+        RLE_compress(start(), getSize(), rle.start(), rle.getSize());
+        takeover(rle);
     }
+
+    // DataManager chunk_norle(data, size);
+    // chunk_norle.writeToFile(dir_path + "chunk_3_out.bin");
+    // printf("3. %d\n", size);
+
 
     // allocate memory and recompress
-    u8* comp_ptr = new u8[size];
-    uLongf comp_size = size;
+    Data comp(size);
 
     switch (console) {
         case CONSOLE::XBOX360:
@@ -102,16 +102,19 @@
             // tinf_compress(comp_ptr, comp_size, data_ptr, data_size);
             break;
         case CONSOLE::WIIU: {
-            ::compress(comp_ptr, &comp_size, data, size);
-            delete[] data;
-            data = comp_ptr;
-            size = comp_size;
+            ::compress(comp.start(), reinterpret_cast<uLongf*>(&comp.size), data, size);
             break;
         }
         default:
             break;
     }
 
+    takeover(comp);
+
+    // DataManager chunk_comp(data, size);
+    // chunk_comp.writeToFile(dir_path + "chunk_4_out.bin");
+    // printf("4. %d\n", size);
+
 
 }
 
Index: LegacyEditor/LCE/headerUnion.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\r\n\r\n#include \"LegacyEditor/utils/endian_swap.hpp\"\r\n#include \"LegacyEditor/utils/processor.hpp\"\r\n\r\nclass HeaderUnion {\r\npublic:\r\n    union {\r\n        struct {\r\n            u32 int1;\r\n            u32 int2;\r\n        } INT_VIEW;\r\n        struct {\r\n            u64 dest_size;\r\n            u16 zlib_magic;\r\n        } ZLIB;\r\n        struct {\r\n            u32 src_size;\r\n            u64 file_size;\r\n        } DAT;\r\n    };\r\n\r\n    ND u32 getInt1() const { return ::isLittleEndian() ? ::swapEndian32(INT_VIEW.int1) : INT_VIEW.int1; }\r\n    ND u32 getInt2() const { return ::isLittleEndian() ? ::swapEndian32(INT_VIEW.int2) : INT_VIEW.int2; }\r\n    ND u64 getDestSize() const { return ::isLittleEndian() ? ::swapEndian64(ZLIB.dest_size) : ZLIB.dest_size; }\r\n    ND u16 getZlibMagic() const { return ::isLittleEndian() ? ::swapEndian16(ZLIB.zlib_magic) : ZLIB.zlib_magic; }\r\n    ND u32 getSrcSize() const { return ::isLittleEndian() ? ::swapEndian32(DAT.src_size) : DAT.src_size; }\r\n    ND u64 getFileSize() const { return ::isLittleEndian() ? ::swapEndian64(DAT.file_size) : DAT.file_size; }\r\n};\r\n
===================================================================
diff --git a/LegacyEditor/LCE/headerUnion.hpp b/LegacyEditor/LCE/headerUnion.hpp
--- a/LegacyEditor/LCE/headerUnion.hpp	
+++ b/LegacyEditor/LCE/headerUnion.hpp	
@@ -18,6 +18,15 @@
             u32 src_size;
             u64 file_size;
         } DAT;
+        struct {
+            u32 garbo;
+            u32 file_size;
+            u32 file_listing_offset;
+        } VITA;
+        struct {
+            u32 file_size;
+            u32 something;
+        } SWITCH;
     };
 
     ND u32 getInt1() const { return ::isLittleEndian() ? ::swapEndian32(INT_VIEW.int1) : INT_VIEW.int1; }
@@ -26,4 +35,9 @@
     ND u16 getZlibMagic() const { return ::isLittleEndian() ? ::swapEndian16(ZLIB.zlib_magic) : ZLIB.zlib_magic; }
     ND u32 getSrcSize() const { return ::isLittleEndian() ? ::swapEndian32(DAT.src_size) : DAT.src_size; }
     ND u64 getFileSize() const { return ::isLittleEndian() ? ::swapEndian64(DAT.file_size) : DAT.file_size; }
+    ND u32 getVitaFileSize() const { return isLittleEndian() ? VITA.file_size : swapEndian32(VITA.file_size) ; }
+    ND u32 getVitaFileListing() const { return isLittleEndian() ? VITA.file_listing_offset : swapEndian32(VITA.file_listing_offset); }
+    ND u32 getSwitchFileSize() const { return isLittleEndian() ? SWITCH.file_size : swapEndian32(SWITCH.file_size); }
+    ND u32 getSwitchSomething() const { return isLittleEndian() ? SWITCH.something : swapEndian32(SWITCH.something); }
+
 };
Index: LegacyEditor/LCE/Region.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"Region.hpp\"\r\n\r\n\r\nChunk* Region::getChunk(int x, int z) {\r\n    int index = x + z * 32;\r\n    if (index > CHUNK_COUNT) return nullptr;\r\n    return &chunks[index];\r\n}\r\n\r\n\r\nChunk* Region::getChunk(int index) {\r\n    if (index > CHUNK_COUNT) return nullptr;\r\n    return &chunks[index];\r\n}\r\n\r\n\r\nvoid Region::read(File* fileIn) {\r\n    totalSectors = fileIn->size / SECTOR_SIZE;\r\n\r\n    // step 0: copying data from file\r\n    DataManager managerIn(fileIn);\r\n\r\n    // step 1: read offsets\r\n    for (Chunk& chunk : chunks) {\r\n        chunk.location = managerIn.readInt24();\r\n        chunk.sectors = managerIn.readByte();\r\n    }\r\n\r\n    // step 2: read timestamps\r\n    for (Chunk& chunk : chunks) {\r\n        chunk.timestamp = managerIn.readInt();\r\n    }\r\n\r\n    // step 3: read chunk size, decompressed size\r\n    int count = 0;\r\n    for (Chunk& chunk : chunks) {\r\n        if (chunk.location + chunk.sectors > totalSectors) {\r\n            printf(\"[%u] chunk sector[%u, %u] end goes outside file...\\n\", totalSectors, chunk.location, chunk.sectors);\r\n        }\r\n\r\n        if (chunk.sectors == 0) continue;\r\n\r\n        // read chunk info\r\n        managerIn.seek(4096 * chunk.location);\r\n        count++;\r\n\r\n        // allocates memory for the chunk\r\n        chunk.size = managerIn.readInt();\r\n        chunk.rleFlag = chunk.size >> 31;\r\n        chunk.size &= 0x3FFFFFFF;\r\n        chunk.allocate(chunk.size);\r\n\r\n        // set chunk's decompressed size attribute\r\n        switch (console) {\r\n            case CONSOLE::PS3:\r\n                chunk.dec_size = managerIn.readInt();\r\n                chunk.dec_size = managerIn.readInt();\r\n                break;\r\n            case CONSOLE::XBOX360:\r\n            case CONSOLE::WIIU:\r\n            default:\r\n                chunk.dec_size = managerIn.readInt();\r\n                break;\r\n        }\r\n\r\n        // each chunk gets its own memory\r\n        memcpy(chunk.start(), managerIn.getPtr(), chunk.size);\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\nData Region::write(CONSOLE consoleIn) {\r\n    // step 1: make sure all chunks are compressed correctly\r\n    // step 2: recalculate sectorCount of each chunk\r\n    // step 3: calculate chunk offsets for each chunk\r\n    int total_sectors = 2;\r\n    int count = 0;\r\n    for (Chunk& chunk : chunks) {\r\n        if (chunk.sectors == 0) {\r\n            chunk.location = 0;\r\n            continue;\r\n        }\r\n\r\n        chunk.ensure_compressed(consoleIn);\r\n        u8 chunk_sectors = (chunk.size + SECTOR_SIZE - 1) / SECTOR_SIZE;\r\n        chunk.location = total_sectors;\r\n        total_sectors += chunk_sectors;\r\n\r\n        count++;\r\n    }\r\n\r\n    // step 4: allocate memory and create buffer\r\n    u32 data_size = total_sectors * SECTOR_SIZE;\r\n    Data dataOut = Data(data_size);\r\n    DataManager managerOut(dataOut);\r\n    managerOut.setLittleEndian();\r\n    // auto* data_ptr = new uint8_t[data_size];\r\n    // DataOutManager dataOut(data_ptr, data_size);\r\n\r\n    // step 5: write each chunk offset\r\n    managerOut.seekStart();\r\n    for (const Chunk& chunk : chunks) {\r\n        managerOut.writeInt24(chunk.location);\r\n        managerOut.writeByte(chunk.sectors);\r\n    }\r\n\r\n    // return dataOut;\r\n\r\n    // step 6: write each chunk timestamp\r\n    for (const Chunk& chunk : chunks) {\r\n        managerOut.writeInt(chunk.timestamp);\r\n    }\r\n\r\n    // step 7: seek to each location, write chunk attr's, then chunk data\r\n    // make sure the pointer is a multiple of SECTOR_SIZE\r\n    for (const Chunk& chunk : chunks) {\r\n        if (chunk.sectors == 0) continue;\r\n        managerOut.seek(chunk.location * 4096);\r\n\r\n        u32 size = chunk.size;\r\n        if (chunk.rleFlag) {\r\n            u32 mask = 0x00FFFFFF;\r\n            size &= mask;\r\n            size |= (0xC0 << 24);\r\n        }\r\n        managerOut.writeInt(size);\r\n\r\n        switch (console) {\r\n            case CONSOLE::PS3:\r\n                managerOut.writeInt(chunk.dec_size);\r\n                managerOut.writeInt(chunk.dec_size);\r\n                break;\r\n            case CONSOLE::XBOX360:\r\n            case CONSOLE::WIIU:\r\n            default:\r\n                managerOut.writeInt(chunk.dec_size);\r\n                break;\r\n        }\r\n        managerOut.write(chunk.start(), chunk.size);\r\n    }\r\n\r\n    return dataOut;\r\n}
===================================================================
diff --git a/LegacyEditor/LCE/Region.cpp b/LegacyEditor/LCE/Region.cpp
--- a/LegacyEditor/LCE/Region.cpp	
+++ b/LegacyEditor/LCE/Region.cpp	
@@ -20,6 +20,10 @@
     // step 0: copying data from file
     DataManager managerIn(fileIn);
 
+    if (console == CONSOLE::VITA) {
+        managerIn.setLittleEndian();
+    }
+
     // step 1: read offsets
     for (Chunk& chunk : chunks) {
         chunk.location = managerIn.readInt24();
@@ -96,9 +100,10 @@
     u32 data_size = total_sectors * SECTOR_SIZE;
     Data dataOut = Data(data_size);
     DataManager managerOut(dataOut);
-    managerOut.setLittleEndian();
-    // auto* data_ptr = new uint8_t[data_size];
-    // DataOutManager dataOut(data_ptr, data_size);
+
+    if (console == CONSOLE::VITA) {
+        managerOut.setLittleEndian();
+    }
 
     // step 5: write each chunk offset
     managerOut.seekStart();
@@ -107,8 +112,6 @@
         managerOut.writeByte(chunk.sectors);
     }
 
-    // return dataOut;
-
     // step 6: write each chunk timestamp
     for (const Chunk& chunk : chunks) {
         managerOut.writeInt(chunk.timestamp);
Index: LegacyEditor/LCE/ConsoleParser.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n#include <cstdio>\r\n\r\n#include \"ConsoleParser.hpp\"\r\n\r\n#include \"LegacyEditor/utils/LZX/XboxCompression.hpp\"\r\n#include \"LegacyEditor/utils/tinf/tinf.h\"\r\n#include \"LegacyEditor/utils/processor.hpp\"\r\n#include <LegacyEditor/utils/zlib-1.2.12/zlib.h>\r\n\r\n\r\nint ConsoleParser::loadWiiU(u32 file_size) {\r\n    printf(\"Detected WiiU savefile, converting\\n\");\r\n    console = CONSOLE::WIIU;\r\n    bool status;\r\n\r\n    // total size of file\r\n    source_binary_size -= 8;\r\n\r\n    Data src = Data(source_binary_size);\r\n\r\n    allocate(file_size);\r\n\r\n    // goto offset 8 for zlib, readBytes data into src\r\n    fseek(f_in, 8, SEEK_SET);\r\n    fread(src.start(), 1, source_binary_size, f_in);\r\n\r\n    // decompress src -> data\r\n    tinf_zlib_uncompress((Bytef*) start(), &getSize(), (Bytef*) src.start(), source_binary_size);\r\n\r\n    if (getSize() == 0) return printf_err(\"%s\", error3);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n/// ps3 save files don't need decompressing\\n\r\n/// TODO: IMPORTANT check from a region file chunk what console it is if it is uncompressed\r\nint ConsoleParser::loadPs3Compressed(u32 dest_size) {\r\n    printf(\"Detected compressed PS3 savefile, converting\\n\");\r\n    console = CONSOLE::PS3;\r\n    int status;\r\n\r\n    // source\r\n    Data src = Data(source_binary_size);\r\n\r\n    // destination\r\n    allocate(dest_size);\r\n\r\n    // decompress src -> data\r\n    fseek(f_in, 12, SEEK_SET);\r\n    src.size -= 12;\r\n    fread(src.start(), 1, src.size, f_in);\r\n    tinf_uncompress(start(), &dest_size, src.start(), src.getSize());\r\n\r\n    if (dest_size == 0) return printf_err(\"%s\", error3);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\nint ConsoleParser::loadPs3Uncompressed() {\r\n    printf(\"Detected uncompressed PS3 savefile, converting\\n\");\r\n    console = CONSOLE::PS3;\r\n\r\n    // allocate memory\r\n    allocate(source_binary_size);\r\n\r\n    // readBytes into data\r\n    fseek(f_in, 0, SEEK_SET);\r\n    fread(start(), 1, size, f_in);\r\n    return 0;\r\n}\r\n\r\n\r\nint ConsoleParser::loadXbox360_DAT() {\r\n    printf(\"Detected Xbox360 .dat savefile, converting\\n\");\r\n    console = CONSOLE::XBOX360;\r\n\r\n    // allocate source memory\r\n    Data src(headerUnion.getSrcSize() - 8);\r\n\r\n    // allocate destination memory\r\n    allocate(headerUnion.getFileSize());\r\n\r\n    // decompress src -> data\r\n    fread(src.start(), 1, src.size, f_in);\r\n    size = XDecompress(start(), &getSize(), src.start(), src.getSize());\r\n\r\n    if (size == 0) return printf_err(\"%s\", error3);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\nint ConsoleParser::loadXbox360_BIN() {\r\n    console = CONSOLE::XBOX360;\r\n    printf(\"Detected Xbox360 .bin savefile, converting\\n\");\r\n\r\n    fseek(f_in, 0, SEEK_SET);\r\n\r\n\r\n    Data bin(source_binary_size);\r\n    fread(bin.start(), 1, source_binary_size, f_in);\r\n\r\n    saveGameInfo = extractSaveGameDat(bin.start(), (i64) source_binary_size);\r\n\r\n    u32 src_size = saveGameInfo.saveFileData.readInt() - 8;\r\n\r\n    size = saveGameInfo.saveFileData.readLong(); // at offset 8\r\n    allocate(size);\r\n    size = XDecompress(start(), &getSize(), saveGameInfo.saveFileData.start(), src_size);\r\n    return 0;\r\n}\r\n\r\n\r\nint ConsoleParser::loadConsoleFile(const char* infileStr) {\r\n\r\n    // open file\r\n    f_in = fopen(infileStr, \"rb\");\r\n    if (f_in == nullptr) {\r\n        printf(\"Cannot open infile %s\", infileStr);\r\n        return -1;\r\n    }\r\n\r\n    fseek(f_in, 0, SEEK_END);\r\n    source_binary_size = ftell(f_in);\r\n    fseek(f_in, 0, SEEK_SET);\r\n    fread(&headerUnion, 1, 12, f_in);\r\n\r\n    int result;\r\n\r\n    // std::cout << headerUnion.getInt1() << std::endl;\r\n    // std::cout << headerUnion.getInt2() << std::endl;\r\n\r\n    if (headerUnion.getInt1() <= 2) {\r\n        u32 file_size = headerUnion.getDestSize();\r\n        /// if (int1 == 0) it is a WiiU savefile unless it's a massive file\r\n        if (headerUnion.getZlibMagic() == ZLIB_MAGIC) {\r\n            result = loadWiiU(file_size);\r\n        } else {\r\n            result = loadPs3Compressed(file_size);\r\n        }\r\n    } else if (headerUnion.getInt2() <= 2) {\r\n        /// if (int2 == 0) it is an xbox savefile unless it's a massive\r\n        /// file, but there won't be 2 files in a savegame file for PS3\r\n        result = loadXbox360_DAT();\r\n    } else if (headerUnion.getInt2() < 100) {\r\n        /// otherwise if (int2) > 50 then it is a random file\r\n        /// because likely ps3 won't have more than 50 files\r\n        result = loadPs3Uncompressed();\r\n    } else if (headerUnion.getInt1() == CON_MAGIC) {\r\n        result = loadXbox360_BIN();\r\n    } else {\r\n        printf(\"%s\", error3);\r\n        result = -1;\r\n    }\r\n\r\n    fclose(f_in);\r\n    return result;\r\n}\r\n\r\n\r\nint ConsoleParser::saveWiiU(const std::string& outfileStr, Data& dataOut) {\r\n    DataManager managerOut(dataOut);\r\n    u64 src_size = managerOut.size;\r\n\r\n    FILE* f_out = fopen(outfileStr.c_str(), \"wb\");\r\n    if (!f_out) { return -1; }\r\n\r\n    // Write src_size to the file\r\n    uLong compressedSize = compressBound(src_size);\r\n    printf(\"compressed bound: %lu\\n\", compressedSize);\r\n\r\n    std::vector<uint8_t> compressedData(compressedSize);\r\n    if (compress(compressedData.data(), &compressedSize, managerOut.start(), managerOut.size) != Z_OK) {\r\n        return {};\r\n    }\r\n    compressedData.resize(compressedSize);\r\n\r\n    int num = 1;\r\n    bool isLittleEndian = *(char*) &num == 1;\r\n    if (isLittleEndian) {\r\n        src_size = swapEndian64(src_size);\r\n    }\r\n\r\n    fwrite(&src_size, sizeof(uint64_t), 1, f_out);\r\n    printf(\"Writing final size: %zu\\n\", compressedData.size());\r\n\r\n    fwrite(compressedData.data(), 1, compressedData.size(), f_out);\r\n\r\n    fclose(f_out);\r\n\r\n\r\n    return 0;\r\n}\r\n\r\n\r\nint ConsoleParser::savePS3Uncompressed() { return 0; }\r\n\r\n\r\nint ConsoleParser::savePS3Compressed() { return 0; }\r\n\r\n\r\nint ConsoleParser::saveXbox360_DAT() { return 0; }\r\n\r\n\r\nint ConsoleParser::saveXbox360_BIN() { return 0; }\r\n\r\n\r\nint ConsoleParser::saveConsoleFile(const char* outfileStr) { return 0; }\r\n
===================================================================
diff --git a/LegacyEditor/LCE/ConsoleParser.cpp b/LegacyEditor/LCE/ConsoleParser.cpp
--- a/LegacyEditor/LCE/ConsoleParser.cpp	
+++ b/LegacyEditor/LCE/ConsoleParser.cpp	
@@ -3,6 +3,7 @@
 
 #include "ConsoleParser.hpp"
 
+#include "LegacyEditor/utils/RLEVITA/rlevita.hpp"
 #include "LegacyEditor/utils/LZX/XboxCompression.hpp"
 #include "LegacyEditor/utils/tinf/tinf.h"
 #include "LegacyEditor/utils/processor.hpp"
@@ -26,7 +27,7 @@
     fread(src.start(), 1, source_binary_size, f_in);
 
     // decompress src -> data
-    tinf_zlib_uncompress((Bytef*) start(), &getSize(), (Bytef*) src.start(), source_binary_size);
+    tinf_zlib_uncompress(start(), &size, src.start(), source_binary_size);
 
     if (getSize() == 0) return printf_err("%s", error3);
 
@@ -85,7 +86,7 @@
 
     // decompress src -> data
     fread(src.start(), 1, src.size, f_in);
-    size = XDecompress(start(), &getSize(), src.start(), src.getSize());
+    size = XDecompress(start(), &size, src.start(), src.getSize());
 
     if (size == 0) return printf_err("%s", error3);
 
@@ -109,11 +110,47 @@
 
     size = saveGameInfo.saveFileData.readLong(); // at offset 8
     allocate(size);
-    size = XDecompress(start(), &getSize(), saveGameInfo.saveFileData.start(), src_size);
+    size = XDecompress(start(), &size, saveGameInfo.saveFileData.start(), src_size);
     return 0;
 }
 
 
+
+int ConsoleParser::loadVita() {
+    printf("Detected Vita savefile, converting\n");
+    console = CONSOLE::VITA;
+
+    // total size of file
+    source_binary_size -= 8;
+    u32 fileSize = headerUnion.getVitaFileSize();
+    std::cout << fileSize << std::endl;
+
+    // allocate memory
+    Data src(source_binary_size);
+    allocate(fileSize);
+
+    // goto offset 8 for the data, read data into src
+    fseek(f_in, 8, SEEK_SET);
+    fread(src.start(), 1, source_binary_size, f_in);
+
+    // uncompressVita();
+    RLEVITA_DECOMPRESS(src.start(), src.size, start(), size);
+
+
+
+    FILE* f_out = fopen("tests/vitaUncompressed.bin", "wb");
+    if (f_out != nullptr) {
+        fwrite(start(), 1, fileSize, f_out);
+        fclose(f_out);
+    } else {
+        printf("Cannot open outfile \"tests/vitaUncompressed.bin\"");
+    }
+
+    return 0;
+}
+
+
+
 int ConsoleParser::loadConsoleFile(const char* infileStr) {
 
     // open file
@@ -130,14 +167,16 @@
 
     int result;
 
-    // std::cout << headerUnion.getInt1() << std::endl;
-    // std::cout << headerUnion.getInt2() << std::endl;
-
     if (headerUnion.getInt1() <= 2) {
         u32 file_size = headerUnion.getDestSize();
+        u32 indexFromSaveFile;
         /// if (int1 == 0) it is a WiiU savefile unless it's a massive file
         if (headerUnion.getZlibMagic() == ZLIB_MAGIC) {
             result = loadWiiU(file_size);
+
+        } else if (indexFromSaveFile = headerUnion.getVitaFileSize() - headerUnion.getVitaFileListing(),
+                   indexFromSaveFile > 0 && indexFromSaveFile < 65536) {
+            result = loadVita();
         } else {
             result = loadPs3Compressed(file_size);
         }
@@ -172,7 +211,7 @@
     uLong compressedSize = compressBound(src_size);
     printf("compressed bound: %lu\n", compressedSize);
 
-    std::vector<uint8_t> compressedData(compressedSize);
+    std::vector<u8> compressedData(compressedSize);
     if (compress(compressedData.data(), &compressedSize, managerOut.start(), managerOut.size) != Z_OK) {
         return {};
     }
@@ -184,7 +223,7 @@
         src_size = swapEndian64(src_size);
     }
 
-    fwrite(&src_size, sizeof(uint64_t), 1, f_out);
+    fwrite(&src_size, sizeof(u64), 1, f_out);
     printf("Writing final size: %zu\n", compressedData.size());
 
     fwrite(compressedData.data(), 1, compressedData.size(), f_out);
Index: LegacyEditor/LCE/ConsoleParser.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\r\n\r\n#include <algorithm>\r\n#include <cstdint>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <zconf.h>\r\n\r\n#include \"LegacyEditor/LCE/BINSupport.hpp\"\r\n#include \"LegacyEditor/LCE/FileInfo.hpp\"\r\n#include \"LegacyEditor/LCE/fileListing.hpp\"\r\n#include \"LegacyEditor/LCE/headerUnion.hpp\"\r\n\r\n\r\nclass ConsoleParser : public Data {\r\nprivate:\r\n    static constexpr u32 CON_MAGIC = 0x434F4E20;\r\n    static constexpr u32 ZLIB_MAGIC = 0x789C;\r\n\r\n    const char* error1 = \"Could not allocate %d bytes of data for source file buffer, exiting\\n\";\r\n    const char* error2 = \"Could not allocate %d bytes of data for source and decompressed buffer, exiting\\n\";\r\n    const char* error3 = \"Not a Minecraft console savefile, exiting\\n\";\r\n\r\n    HeaderUnion headerUnion{};\r\n\r\npublic:\r\n    FileInfo saveGameInfo;\r\n    u8 header[0xc]{};\r\n    CONSOLE console = CONSOLE::NONE;\r\n    FILE* f_in{};\r\n    u64 source_binary_size{};\r\n\r\n    ConsoleParser() : Data() {}\r\n\r\n    int loadWiiU(u32 file_size);\r\n    int loadPs3Compressed(u32 dest_size);\r\n    int loadPs3Uncompressed();\r\n    int loadXbox360_DAT();\r\n    int loadXbox360_BIN();\r\n\r\n    int loadConsoleFile(const char* infileStr);\r\n\r\n    static int saveWiiU(const std::string& outfileStr, Data& dataOut);\r\n    int savePS3Uncompressed();\r\n    int savePS3Compressed();\r\n    int saveXbox360_DAT();\r\n    int saveXbox360_BIN();\r\n    int saveConsoleFile(const char* outfileStr);\r\n};\r\n
===================================================================
diff --git a/LegacyEditor/LCE/ConsoleParser.hpp b/LegacyEditor/LCE/ConsoleParser.hpp
--- a/LegacyEditor/LCE/ConsoleParser.hpp	
+++ b/LegacyEditor/LCE/ConsoleParser.hpp	
@@ -38,6 +38,8 @@
     int loadXbox360_DAT();
     int loadXbox360_BIN();
 
+    int loadVita();
+
     int loadConsoleFile(const char* infileStr);
 
     static int saveWiiU(const std::string& outfileStr, Data& dataOut);
Index: LegacyEditor/LCE/fileListing.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"fileListing.hpp\"\r\n\r\n#include <iostream>\r\n\r\n\r\ninline bool endswith(const std::string& value, const std::string& ending) {\r\n    if (ending.size() > value.size()) return false;\r\n    return std::equal(ending.rbegin(), ending.rend(), value.rbegin());\r\n}\r\n\r\n\r\ninline bool startswith(const std::string& value, const std::string& prefix) {\r\n    if (prefix.size() > value.size()) return false;\r\n    return std::equal(prefix.begin(), prefix.end(), value.begin());\r\n}\r\n\r\n\r\nvoid FileListing::read(Data& dataIn) {\r\n    DataManager managerIn(dataIn);\r\n\r\n    u32 indexOffset = managerIn.readInt();\r\n    u32 fileCount = managerIn.readInt();\r\n    oldestVersion = managerIn.readShort();\r\n    currentVersion = managerIn.readShort();\r\n    u32 total_size = 0;\r\n\r\n    allFiles.clear();\r\n    allFiles.reserve(fileCount);\r\n    // printf(\"\\nFile Count: %u\\n\", fileCount);\r\n    // printf(\"Buffer Size: %u\\n\", managerIn.size);\r\n\r\n    for (int fileIndex = 0; fileIndex < fileCount; fileIndex++) {\r\n        managerIn.seek(indexOffset + fileIndex * 144);\r\n\r\n\r\n        std::string fileName = managerIn.readWAsString(64); // m 128 bytes / 2 per char\r\n        std::string originalFileName = fileName;\r\n\r\n        u32 fileSize = managerIn.readInt();\r\n        total_size += fileSize;\r\n\r\n        u8* data = nullptr;\r\n        u32 index = managerIn.readInt();\r\n        u64 timestamp = managerIn.readLong();\r\n\r\n        if (!fileSize) {\r\n            printf(\"Skipping empty file \\\"%s\\\"\\n\", fileName.c_str());\r\n            continue;\r\n        }\r\n\r\n        managerIn.seek(index);\r\n        data = managerIn.readBytes(fileSize);\r\n\r\n        allFiles.emplace_back(data, fileSize, fileName, timestamp);\r\n\r\n        File& file = allFiles.back();\r\n\r\n        if (endswith(fileName, \".mcr\")) {\r\n            if (startswith(fileName, \"DIM-1\")) {\r\n                netherFilePtrs.push_back(&file);\r\n            } else if (startswith(fileName, \"DIM1\")) {\r\n                endFilePtrs.push_back(&file);\r\n            } else if (startswith(fileName, \"r\")) {\r\n                overworldFilePtrs.push_back(&file);\r\n            } else {\r\n                printf(\"File '%s' is not from any dimension!\\n\", fileName.c_str());\r\n                continue;\r\n            }\r\n        } else if (fileName == \"level.dat\") {\r\n            levelFilePtr = &file;\r\n        } else if (startswith(fileName, \"data/map_\")) {\r\n            mapFilePtrs.push_back(&file);\r\n        } else if (fileName == \"data/villages.dat\") {\r\n            villageFilePtr = &file;\r\n        } else if (startswith(fileName, \"data/\")) {\r\n            structureFilePtrs.push_back(&file);\r\n        } else if (endswith(fileName, \".grf\")) {\r\n            grfFilePtr = &file;\r\n        } else if (startswith(fileName, \"players/\")) {\r\n            playerFilePtrs.push_back(&file);\r\n        } else if (fileName.find('/') == -1) {\r\n            playerFilePtrs.push_back(&file);\r\n        } else {\r\n            printf(\"Unknown File: %s\\n\", fileName.c_str());\r\n        }\r\n        // printf(\"%2u. (@%7u)[%7u]  - %s\\n\", fileIndex + 1, index, file.size, originalFileName.c_str());\r\n    }\r\n    // printf(\"Total File Size: %u\\n\\n\", total_size);\r\n\r\n}\r\n\r\n\r\nData FileListing::write() {\r\n\r\n    // step 1: get the file count and size of all sub-files\r\n    u32 fileCount = 0;\r\n    u32 fileDataSize = 0;\r\n    for (const File& file: allFiles) {\r\n        fileCount++;\r\n        fileDataSize += file.getSize();\r\n    }\r\n    u32 fileInfoOffset = fileDataSize + 12;\r\n\r\n    // printf(\"\\nTotal File Count: %u\\n\", fileCount);\r\n    // printf(\"Total File Size: %u\\n\", fileDataSize);\r\n\r\n    // step 2: find total binary size and create its data buffer\r\n    u32 totalFileSize = fileInfoOffset + 144 * fileCount;\r\n\r\n    Data dataOut(totalFileSize);\r\n    DataManager managerOut(dataOut);\r\n\r\n    // step 3: write start\r\n    managerOut.writeInt(fileInfoOffset);\r\n    managerOut.writeInt(fileCount);\r\n    managerOut.writeShort(oldestVersion);\r\n    managerOut.writeShort(currentVersion);\r\n\r\n\r\n    // step 4: write each files data\r\n    // I am using additionalData as the offset into the file its data is at\r\n    u32 index = 12;\r\n    for (File& fileIter: allFiles) {\r\n        fileIter.additionalData = index;\r\n        index += fileIter.getSize();\r\n        managerOut.writeFile(fileIter);\r\n    }\r\n\r\n    // step 5: write file metadata\r\n    // std::cout << \"\\nwriting back to file\" << std::endl;\r\n    int count = 0;\r\n    for (File& fileIter: allFiles) {\r\n        // printf(\"%2u. (@%7u)[%7u] - %s\\n\", count + 1, fileIter.additionalData, fileIter.size, fileIter.name.c_str());\r\n\r\n        managerOut.writeWString(fileIter.name, 64);\r\n        managerOut.writeInt(fileIter.getSize());\r\n\r\n        // if (!fileIter.isEmpty()) {\r\n        managerOut.writeInt(fileIter.additionalData);\r\n        managerOut.writeLong(fileIter.timestamp);\r\n        // }\r\n        count++;\r\n    }\r\n\r\n    // printf(\"Buffer Size: %u\\n\", data.size);\r\n\r\n    return dataOut;\r\n}\r\n
===================================================================
diff --git a/LegacyEditor/LCE/fileListing.cpp b/LegacyEditor/LCE/fileListing.cpp
--- a/LegacyEditor/LCE/fileListing.cpp	
+++ b/LegacyEditor/LCE/fileListing.cpp	
@@ -17,6 +17,9 @@
 
 void FileListing::read(Data& dataIn) {
     DataManager managerIn(dataIn);
+    if (console == CONSOLE::VITA) {
+        managerIn.setLittleEndian();
+    }
 
     u32 indexOffset = managerIn.readInt();
     u32 fileCount = managerIn.readInt();
@@ -110,6 +113,10 @@
     Data dataOut(totalFileSize);
     DataManager managerOut(dataOut);
 
+    if (console == CONSOLE::VITA) {
+        managerOut.setLittleEndian();
+    }
+
     // step 3: write start
     managerOut.writeInt(fileInfoOffset);
     managerOut.writeInt(fileCount);
Index: LegacyEditor/LCE/fileListing.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\r\n\r\n#include \"LegacyEditor/utils/enums.hpp\"\r\n#include \"LegacyEditor/utils/file.hpp\"\r\n#include \"LegacyEditor/utils/processor.hpp\"\r\n\r\n#include \"LegacyEditor/utils/dataManager.hpp\"\r\n\r\n#include <vector>\r\n\r\n\r\nclass FileListing {\r\npublic:\r\n    // TODO IMPORTANT: RESIZING OF VECTORS BREAKS DE_ALLOCATION\r\n    std::vector<File> allFiles;\r\n\r\n    // files\r\n    std::vector<File*> overworldFilePtrs;\r\n    std::vector<File*> netherFilePtrs;\r\n    std::vector<File*> endFilePtrs;\r\n    File* levelFilePtr{};\r\n    File* grfFilePtr{};\r\n    std::vector<File*> mapFilePtrs;\r\n    std::vector<File*> structureFilePtrs;\r\n    File* villageFilePtr{};\r\n    std::vector<File*> playerFilePtrs;\r\n\r\n    // data\r\n    i32 oldestVersion{};\r\n    i32 currentVersion{};\r\n\r\n    FileListing() = default;\r\n\r\n    explicit FileListing(Data& dataIn) {\r\n        read(dataIn);\r\n    }\r\n\r\n    void read(Data& dataIn);\r\n    Data write();\r\n\r\n\r\n};
===================================================================
diff --git a/LegacyEditor/LCE/fileListing.hpp b/LegacyEditor/LCE/fileListing.hpp
--- a/LegacyEditor/LCE/fileListing.hpp	
+++ b/LegacyEditor/LCE/fileListing.hpp	
@@ -10,6 +10,9 @@
 
 
 class FileListing {
+private:
+    CONSOLE console = CONSOLE::NONE;
+
 public:
     // TODO IMPORTANT: RESIZING OF VECTORS BREAKS DE_ALLOCATION
     std::vector<File> allFiles;
@@ -29,13 +32,15 @@
     i32 oldestVersion{};
     i32 currentVersion{};
 
-    FileListing() = default;
+    FileListing(CONSOLE consoleIn) : console(consoleIn) {}
 
-    explicit FileListing(Data& dataIn) {
+    explicit FileListing(CONSOLE consoleIn, Data& dataIn) : console(consoleIn) {
         read(dataIn);
     }
 
+private:
     void read(Data& dataIn);
+public:
     Data write();
 
 
